状压 dp
=======

.. piximg:: 61717423

想当年我唯一会做的状压 dp 就是“炮兵阵地”，
然后各种觉得状压 dp 非常神奇。
近来水了一波状压 dp 模板题，
发现数据范围从来没超过 20 ，
woc 那岂不是狂扫一般 QwQ

.. piximg:: 61061723

poj3311_
--------

.. _poj3311: http://poj.org/problem?id=3311

从起点出发，遍历图上每个点，最后回到起点，求最小花费。

.. piximg:: 52707082

这玩意不是旅行商问题吗？数据范围一大就 GG 。
幸好本题数据范围超小，直接状压就行了。

为了 dp ，我们的状态显然需要包含我们已经到了哪些点的信息
（因为我们要遍历每个点）。
这是一个集合。为了方便表示状态，我们可以用一个二进制表示已经到了哪些点
（这得益于点数极少），置 1 表示已到，置 0 表示未到。
搞一个 dp 数组 :math:`f[当前点][已到点的状压]` ，
则我们要求的就是 :math:`f[初始点][(1 \mathbin{<<} 点数) - 1]` ，转移是：

.. math::
    f[v][state \mathbin{|} (1 \mathbin{<<} v)] =
    &min(f[u][state] + distance[u][v]) \\
    &\mathrel{for} u, v \in vertexs

状压实在太暴力了。。。

.. code-block:: C++

    #include <cstdio>
    #include <cstdlib>
    #include <cstring>
    #include <vector>
    using namespace std;
    const int maxn = 11;
    const int inf = 0x4f4f4f4f;
    int n;
    int G[maxn][maxn];
    int f[maxn][1 << maxn];
    static int dp(const int u, const int s){
        int &ans = f[u][s];
        if(ans != -1)
            return ans;
        ans = inf;
        for(int v = 0; v < n; ++v){
            const int dists = s | (1 << v);
            if(v == 0 and dists == (1 << n) - 1)
                ans = min(ans, G[u][v]);
            else
                ans = min(ans, dp(v, dists) + G[u][v]);
        }
        return ans;
    }
    static void _(void){
        scanf("%d", &n);
        if(n++ == 0)
            exit(0);
        for(int i = 0; i < n; ++i)
            for(int j = 0; j < n; ++j){
                int t;
                scanf("%d", &t);
                G[i][j] = t;
            }
        memset(f, -1, sizeof(f));
        printf("%d\n", dp(0, 1));
    }
    int main(void){
        while(true) _();
    }

hdu1074_
--------

.. _hdu1074: http://acm.split.hdu.edu.cn/showproblem.php?pid=1074

有若干项作业，每项作业都有完成所需时间和死线，超过死线一天扣一分，
求最小扣分。

.. piximg:: 62130898

狂扫就对了， dp 数组 :math:`f[当前是第几天][已完成作业的状压]` ，转移：

.. math::
    f[curday + cost_v][state \mathbin{|} (1 \mathbin{<<} v)] =
    &min(f[curday][state] + max(0, curday + cost_v - deadline_v)) \\
    &\mathrel{for} v \in homeworks, \notin state

复杂度不敢想象。。。方案输出只要 dp 时记录前驱即可。

.. code-block:: C++

    #include <cstdio>
    #include <cstring>
    #include <vector>
    #include <string>
    using namespace std;
    const int maxn = 15;
    const int inf = 0x4f4f4f4f;
    int n;
    int lms[maxn], tms[maxn];
    int f[1 << maxn];
    int pre[1 << maxn];
    string names[maxn];
    static int dp(const int s, const int cur){
        int &ans = f[s];
        if(ans != -1)
            return ans;
        ans = inf;
        for(int i = 0; i < n; ++i){
            const int dists = s | (1 << i);
            if(dists != s){
                const int rv = dp(dists, cur + tms[i]) + max(0, cur + tms[i] - lms[i]);
                if(rv < ans){
                    ans = rv;
                    pre[s] = dists;
                }
            }
        }
        return ans;
    }
    static int bidx(int x){
        for(int i = 0; ; ++i, x >>= 1)
            if(x & 1)
                return i;
        return -1;
    }
    static void print(const int s){
        if(pre[s] != -1){
            printf("%s\n", names[bidx(pre[s] ^ s)].c_str());
            print(pre[s]);
        }
    }
    static void _(void){
        scanf("%d", &n);
        for(int i = 0; i < n; ++i){
            char name[101];
            int limit, time;
            scanf("%s%d%d", name, &limit, &time);
            names[i] = name;
            lms[i] = limit;
            tms[i] = time;
        }
        memset(f, -1, sizeof(f));
        memset(pre, -1, sizeof(pre));
        f[(1 << n) - 1] = 0;
        printf("%d\n", dp(0, 0));
        print(0);
    }
    int main(void){
        int T;
        scanf("%d", &T);
        while(T--)
            _();
        return 0;
    }

loj1038_
--------

.. _loj1038: http://lightoj.com/volume_showproblem.php?problem=1038

咦，怎么混进来一道期望 dp 。

一个数可以通过一次操作变成它的因数（包括 1 和它自己），
对于这个数每个因数而言，变成它的概率为
:math:`\frac{1}{原数因数个数}` 。
给定一个数，求它变成 1 期望的操作步数。

.. piximg:: 53733717

对于期望 dp 我真是一点都不会。
我对于期望目前的理解：

.. math::
    期望[状态u] = sum((期望[状态v] + 1) * 转移概率[u \rightarrow v])

（就是以概率为权的平均数嘛 QwQ）

本题的转移：（由于可以转移到自己，所以要移项）

.. math::
    f[x] &= \sum_{i = 1}^{m} \frac{f[p_i] + 1}{m} \\
    f[x] - \frac{f[x] + 1}{m} &= \frac{\sum_{i = 1}^{m - 1} (f[p_i] + 1)}{m} \\
    \frac{m - 1}{m} f[x] &= \frac{\sum_{i = 1}^{m - 1} f[p_i]}{m} + 1 \\
    f[x] &= \frac{(\sum_{i = 1}^{m - 1} f[p_i]) + m}{m - 1} \\
    \mathrel{where} p &= sorted(diviors\_of\_x) \\
    m &= len(p)

碰到数学就挂.jpg

.. code-block:: C++

    #include <cstdio>
    #include <vector>
    using namespace std;

    const int maxn = 100001;
    double f[maxn];

    static inline void init_f(void){
        for(int i = 0; i < maxn; ++i)
            f[i] = -1;
        f[1] = 0;
    }

    static double dp(const int n){
        double &ans = f[n];
        if(ans != -1)
            return ans;
        
        vector<int> divs;
        for(int i = 1; 1ll * i * i <= n; ++i)
            if(n % i == 0){
                divs.push_back(i);
                if(n / i != i and i != 1)
                    divs.push_back(n / i);
            }

        const int m = divs.size() + 1;
        ans = m;
        for(int p : divs)
            ans += dp(p);
        return ans /= m - 1;
    }

    static void run_all(void){
        init_f();
        for(int i = 1; i < maxn; ++i)
            dp(i);
    }

    int main(void){
        run_all();
        int T; scanf("%d", &T);
        for(int kase = 1; kase <= T; ++kase){
            int n; scanf("%d", &n);
            printf("Case %d: %f\n", kase, dp(n));
        }
        return 0;
    }

hdu4336_
--------

.. _hdu4336: http://acm.split.hdu.edu.cn/showproblem.php?pid=4336

每包零食里可能有一张卡片或没有卡片，
每种卡片都有一定出现概率。
求得到所有种卡片要多少包零食的期望。

.. piximg:: 61617710

这看起来就像一道期望 dp （呃）。
重点是状态的表示。
显然我们可以用已经收集到的卡片种类的状压表示状态。
一个状态可以向多一种卡片的状态转移（抽到一张新卡），
或者向自己转移（没抽到卡或抽到已经抽到的卡）。
转移：

.. math::
    f[state] = \sum_{i = 1}^{N} f[state \mathbin{\&} \mathrel{\sim} (1 \mathbin{<<} i)] \times p_i + f[state] \times (1 - \sum_{i = 1}^{N} p_i)

移项就靠自己移了。注意 :math:`state \mathbin{\&} \mathrel{\sim} (1 \mathbin{<<} i) = state` 也是有可能的。

.. code-block:: C++

    #include <cstdio>
    #include <cstdlib>
    using namespace std;
    const int maxn = 20;
    int n;
    double a[maxn];
    double f[1 << maxn];
    static double dp(const int s){
        double &ans = f[s];
        if(ans != -1)
            return ans;
        ans = 1;
        double sp = 0;
        for(int i = 0; i < n; ++i)
            if(s & (1 << i)){
                ans += dp(s ^ (1 << i)) * a[i];
                sp += a[i];
            }
        return ans /= sp;
    }
    static void _(void){
        if(scanf("%d", &n) != 1)
            exit(0);
        for(int i = 0; i < n; ++i)
            scanf("%lf", a + i);
        for(int i = 0; i < (1 << n); ++i)
            f[i] = -1;
        f[0] = 0;
        printf("%f\n", dp((1 << n) - 1));
    }
    int main(void){
        while(true)
            _();
    }

hdu3001_
--------

.. _hdu3001: http://acm.split.hdu.edu.cn/showproblem.php?pid=3001

从任一一个点出发遍历图上每个点，每个点经过次数不能超过两次。

.. piximg:: 65032767

这题唯一的区别之处在于每个点有三个状态而不是两个：
未访问，访问一次（还能再访问），访问两次（不能再访问）。
因此用三进制来状压就行了。

.. code-block:: C++

    #include <cstdio>
    #include <cstring>
    #include <cstdlib>
    #include <vector>
    #include <algorithm>
    using namespace std;

    const int maxn = 10;
    const int magic = 59049;
    const int inf = 0x3f3f3f3f;
    int n, m;
    int f[maxn][magic];
    int G[maxn][maxn];

    static vector<int> split3(int x){
        vector<int> v(n);
        for(int i = 0; i < n; ++i){
            v[i] = x % 3;
            x /= 3;
        }
        return v;
    }

    static int merge3(vector<int> const &v){
        int x = 0;
        for(vector<int>::const_reverse_iterator it(v.rbegin()), ed(v.rend()); it != ed; ++it)
            x = x * 3 + * it;
        return x;
    }

    static int dp(const int u, const int s){
        int &ans = f[u][s];
        if(ans != -1)
            return ans;

        ans = inf;
        vector<int> ss(split3(s));
        for(int v = 0; v < n; ++v){
            if(G[u][v] == -1)
                continue;
            if(ss[v] == 2)
                continue;

            ++ss[v];
            ans = min(ans, dp(v, merge3(ss)) + G[u][v]);
            --ss[v];
        }
        return min(inf, ans);
    }

    static void _(void){
        if(scanf("%d%d", &n, &m) != 2)
            exit(0);
        memset(G, -1, sizeof(G));
        for(int i = 0; i < m; ++i){
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            --u; --v;
            G[u][v] = min((unsigned)G[u][v], (unsigned)w);
            G[v][u] = min((unsigned)G[v][u], (unsigned)w);
        }

        memset(f, -1, sizeof(f));
        for(int j = 0; j < magic; ++j){
            vector<int> ss(split3(j));
            if(find(ss.begin(), ss.end(), 0) == ss.end())
                for(int i = 0; i < n; ++i)
                    f[i][j] = 0;
        }

        int ans = inf;
        vector<int> is(n);
        for(int i = 0; i < n; ++i){
            is[i] = 1;
            ans = min(ans, dp(i, merge3(is)));
            is[i] = 0;
        }
        if(ans == inf)
            puts("-1");
        else
            printf("%d\n", ans);
    }

    int main(void){
        while(true)
            _();
    }

cf11d_
------

.. _cf11d: http://codeforces.com/problemset/problem/11/D

这是我见过最远古的 cf 题了。。。

给一个简单图，输出简单环的数量。简单环是一个没有重点或重边的环。

.. piximg:: 42201199

从每个点出发跑一次，沿简单路径跑回来就是一个简单环。
但会有重复计算，因为环上每个点都可以作为起点。
所以我们指定跑的方向，比如环上点的标号要大于起点，
这样就保证了起点是环上标号最小点，就没有重复了。
简单路径就用状压 dp 来搞。转移：

.. math::
    f[u][state][last][start] &=
    sum(&f[v][state \mathbin{|} (1 \mathbin{<<} v)][u][start]) \\
    &&\mathrel{for} u \rightarrow v \\
    &&\mathrel{if} v \notin state \\
    f[u][state][last][u] &= 1 &\mathrel{if} u \neq last

这题好像只有两个点是不算环的，因此加一个 last 判一下。

.. code-block:: C++

    #include <cstdio>
    #include <cstring>
    #include <vector>
    using namespace std;
    const int maxn = 19;
    int n, m;
    vector<int> G[maxn];
    long long f[maxn][1 << maxn];
    long long dp(const int u, const int s, const int last, const int bound){
        long long &ans = f[u][s];
        if(ans != -1)
            return ans;
        ans = 0;
        for(int v : G[u])
            if(v > bound){
                const int dists = s | (1 << v);
                if(dists != s)
                    ans += dp(v, dists, u, bound);
            }else if(v == bound and last != bound)
                ++ans;
        return ans;
    }
    int main(void){
        scanf("%d%d", &n, &m);
        for(int i = 0; i < m; ++i){
            int u, v;
            scanf("%d%d", &u, &v);
            --u; --v;
            G[u].push_back(v);
            G[v].push_back(u);
        }
        long long ans = 0;
        for(int i = 0; i < n; ++i){
            memset(f, -1, sizeof(f));
            ans += dp(i, 1 << i, -1, i) / 2;
        }
        printf("%lld\n", ans);
        return 0;
    }

cf417d_
-------

.. _cf417d: http://codeforces.com/problemset/problem/417/D

你有一套题，然而你是菜鸡不会切题，所以你找 py 做。
每个 py 都只会切自己会做的题（给出），并且作为报酬，
你要给他一定的钱；而且神奇的是每个 py 都要一定数量的显示器才能切题。
初始时你没有显示器，买一台显示器要一定的钱。
求最小花费。

.. piximg:: 58532939

如果不考虑显示器，那么是一道清真的状压 dp 。但是显示器就比较难办。
显示器是可以累积的。因此我们可以把 py 按需要显示器数量从小到大排序。
在像背包一样拣 py 时，当显示器不够就去买，每轮算一次答案，
算上显示器的价格。因为已经排过序，因此不会有冗余的显示器。
（这个解释能看懂就怪了）

.. code-block:: C++

    #include <cstdio>
    #include <cstring>
    #include <algorithm>
    using namespace std;

    typedef long long ll;
    const ll inf = 0x4f4f4f4f4f4f4f4f;
    const int maxn = 100;
    const int maxm = 20;

    struct Py{
        int x, k, c;
        Py(const int x=0, const int k=0, const int c=0):
            x(x),
            k(k),
            c(c){}
    }a[maxn];
    int n, m, b;
    ll f[1 << maxm];

    static inline bool ltk(const Py l, const Py r){
        return l.k < r.k;
    }

    template<typename T> static inline void updatemin(T& a, T const &b){
        a = min(a, b);
    }

    int main(void){
        scanf("%d%d%d", &n, &m, &b);
        for(int i = 0; i < n; ++i){
            int xi, ki, mi, ci = 0;
            scanf("%d%d%d", &xi, &ki, &mi);
            while(mi--){
                int t;
                scanf("%d", &t);
                --t;
                ci |= 1 << t;
            }
            a[i] = Py(xi, ki, ci);
        }

        sort(a, a + n, ltk);

        ll ans = inf;
        memset(f, 0x4f, sizeof(f));
        f[0] = 0;
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < 1 << m; ++j)
                updatemin(f[j | a[i].c], f[j] + a[i].x);
            updatemin(ans, f[(1 << m) - 1] + 1ll * a[i].k * b);
        }
        printf("%lld\n", ans == inf ? -1ll : ans);
        return 0;
    }

LAST
----

博客写得累死。。。

.. piximg:: 32221412
